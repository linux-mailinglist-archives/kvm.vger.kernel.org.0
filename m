Return-Path: <kvm+bounces-62495-lists+kvm=lfdr.de@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [IPv6:2604:1380:45e3:2400::1])
	by mail.lfdr.de (Postfix) with ESMTPS id 6C945C45976
	for <lists+kvm@lfdr.de>; Mon, 10 Nov 2025 10:19:58 +0100 (CET)
Received: from smtp.subspace.kernel.org (relay.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-ECDSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id 021343B71C4
	for <lists+kvm@lfdr.de>; Mon, 10 Nov 2025 09:18:53 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 6EBBA2FE570;
	Mon, 10 Nov 2025 09:18:49 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b="prmW4Q/x"
X-Original-To: kvm@vger.kernel.org
Received: from smtp.kernel.org (aws-us-west-2-korg-mail-1.web.codeaurora.org [10.30.226.201])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 86476155389;
	Mon, 10 Nov 2025 09:18:48 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=10.30.226.201
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1762766328; cv=none; b=EInmAmX/u9Y9oE6xLsRmHD8H6YLQFVPXWMFUe+sFE53w/b48YRZv9z8AgIEt9Mbro1BeU8p1Nci3EZAj3RxYc5aYDl9sJFBuO3hTfXaqQnRPdk29ia0qDOteKWXli+tAUqVj6zbHA6BbkL6LN4q0HGgwoeeR0z/iaNASWVl3dQA=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1762766328; c=relaxed/simple;
	bh=uquc9KPzJLqmrUGTtW/WL79DTxEiUuvrMXU31YBoEgg=;
	h=Date:Message-ID:From:To:Cc:Subject:In-Reply-To:References:
	 MIME-Version:Content-Type; b=U8z72WdEmfFZMo3Gx3AiBOfNITgTgBhErVGxZ2wKO1JPl2DPE0262SejqFF0U/FkG45FASTkHdi51p+yFJeE2kxtVVy4Y2cCJRg/ZYhbMlycwtsdNwdVncLfC6U7KZfVfVmHYhQAfI0PTkcbNrCtdmAEnnHhVvo9D5jzKfVpXWg=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b=prmW4Q/x; arc=none smtp.client-ip=10.30.226.201
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 13815C16AAE;
	Mon, 10 Nov 2025 09:18:48 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=k20201202; t=1762766328;
	bh=uquc9KPzJLqmrUGTtW/WL79DTxEiUuvrMXU31YBoEgg=;
	h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
	b=prmW4Q/xtwy2U5A6XdV9MSU5SGHVbHRrvnGWIZ4Wvk+xk9VUnAj/WgdjB2BXMeoKQ
	 g7py08T3FWOAYMO6srNNHyJG88jTnnn6QDfAPEKquhu6jQxZgNWGJ6FvU46LlybaZh
	 W1rMqEFKcQ2y35yYheggf10/1U4tQKMyvYK+SdsgwgOD2Xdm6FNhrAi8VEYvvZ1/AI
	 X6vA5eKJplGbNSM7OmNOma6PbGxfybGNHRMlN2di/pJ/B8KsqwqleSRUSYBWeicgth
	 1OZ2gVSR9cZF8qLpRAbeoTbpjsoA7MInJlN1F5Bq0QvrgxSJH5wXPP/NBj5V6qUsLG
	 c8HK2bD4r4rIQ==
Received: from sofa.misterjones.org ([185.219.108.64] helo=goblin-girl.misterjones.org)
	by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	(Exim 4.98.2)
	(envelope-from <maz@kernel.org>)
	id 1vIO2v-00000003nJj-2qRt;
	Mon, 10 Nov 2025 09:18:45 +0000
Date: Mon, 10 Nov 2025 09:18:45 +0000
Message-ID: <868qgeutxm.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Yao Yuan <yaoyuan@linux.alibaba.com>
Cc: kvmarm@lists.linux.dev,
	linux-arm-kernel@lists.infradead.org,
	kvm@vger.kernel.org,
	Joey Gouly <joey.gouly@arm.com>,
	Suzuki K Poulose <suzuki.poulose@arm.com>,
	Oliver Upton <oupton@kernel.org>,
	Zenghui Yu <yuzenghui@huawei.com>,
	Christoffer Dall <christoffer.dall@arm.com>,
	Volodymyr Babchuk <Volodymyr_Babchuk@epam.com>
Subject: Re: [PATCH v2 12/45] KVM: arm64: GICv3: Extract LR folding primitive
In-Reply-To: <3tb7ekdzl5f4rs24bla63vw22awejhbn7ngvttid7v7bzaer2m@62bxshf7uj34>
References: <20251109171619.1507205-1-maz@kernel.org>
	<20251109171619.1507205-13-maz@kernel.org>
	<3tb7ekdzl5f4rs24bla63vw22awejhbn7ngvttid7v7bzaer2m@62bxshf7uj34>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/30.1
 (aarch64-unknown-linux-gnu) MULE/6.0 (HANACHIRUSATO)
Precedence: bulk
X-Mailing-List: kvm@vger.kernel.org
List-Id: <kvm.vger.kernel.org>
List-Subscribe: <mailto:kvm+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:kvm+unsubscribe@vger.kernel.org>
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: yaoyuan@linux.alibaba.com, kvmarm@lists.linux.dev, linux-arm-kernel@lists.infradead.org, kvm@vger.kernel.org, joey.gouly@arm.com, suzuki.poulose@arm.com, oupton@kernel.org, yuzenghui@huawei.com, christoffer.dall@arm.com, Volodymyr_Babchuk@epam.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false

On Mon, 10 Nov 2025 09:01:21 +0000,
Yao Yuan <yaoyuan@linux.alibaba.com> wrote:
> 
> On Sun, Nov 09, 2025 at 05:15:46PM +0800, Marc Zyngier wrote:
> > As we are going to need to handle deactivation for interrupts that
> > are not in the LRs, split vgic_v3_fold_lr_state() into a helper
> > that deals with a single interrupt, and the function that loops
> > over the used LRs.
> >
> > Signed-off-by: Marc Zyngier <maz@kernel.org>
> > ---
> >  arch/arm64/kvm/vgic/vgic-v3.c | 88 +++++++++++++++++------------------
> >  1 file changed, 43 insertions(+), 45 deletions(-)
> >
> > diff --git a/arch/arm64/kvm/vgic/vgic-v3.c b/arch/arm64/kvm/vgic/vgic-v3.c
> > index 3ede79e381513..0fccfe9e3e8dd 100644
> > --- a/arch/arm64/kvm/vgic/vgic-v3.c
> > +++ b/arch/arm64/kvm/vgic/vgic-v3.c
> > @@ -33,78 +33,76 @@ static bool lr_signals_eoi_mi(u64 lr_val)
> >  	       !(lr_val & ICH_LR_HW);
> >  }
> >
> > -void vgic_v3_fold_lr_state(struct kvm_vcpu *vcpu)
> > +static void vgic_v3_fold_lr(struct kvm_vcpu *vcpu, u64 val)
> >  {
> > -	struct vgic_cpu *vgic_cpu = &vcpu->arch.vgic_cpu;
> > -	struct vgic_v3_cpu_if *cpuif = &vgic_cpu->vgic_v3;
> > -	u32 model = vcpu->kvm->arch.vgic.vgic_model;
> > -	int lr;
> > -
> > -	DEBUG_SPINLOCK_BUG_ON(!irqs_disabled());
> > -
> > -	cpuif->vgic_hcr &= ~ICH_HCR_EL2_UIE;
> > -
> > -	for (lr = 0; lr < cpuif->used_lrs; lr++) {
> > -		u64 val = cpuif->vgic_lr[lr];
> > -		u32 intid, cpuid;
> > -		struct vgic_irq *irq;
> > -		bool is_v2_sgi = false;
> > -		bool deactivated;
> > -
> > -		cpuid = val & GICH_LR_PHYSID_CPUID;
> > -		cpuid >>= GICH_LR_PHYSID_CPUID_SHIFT;
> > -
> > -		if (model == KVM_DEV_TYPE_ARM_VGIC_V3) {
> > -			intid = val & ICH_LR_VIRTUAL_ID_MASK;
> > -		} else {
> > -			intid = val & GICH_LR_VIRTUALID;
> > -			is_v2_sgi = vgic_irq_is_sgi(intid);
> > -		}
> > +	struct vgic_irq *irq;
> > +	bool is_v2_sgi = false;
> > +	bool deactivated;
> > +	u32 intid;
> >
> > -		/* Notify fds when the guest EOI'ed a level-triggered IRQ */
> > -		if (lr_signals_eoi_mi(val) && vgic_valid_spi(vcpu->kvm, intid))
> > -			kvm_notify_acked_irq(vcpu->kvm, 0,
> > -					     intid - VGIC_NR_PRIVATE_IRQS);
> > +	if (vcpu->kvm->arch.vgic.vgic_model == KVM_DEV_TYPE_ARM_VGIC_V3) {
> > +		intid = val & ICH_LR_VIRTUAL_ID_MASK;
> > +	} else {
> > +		intid = val & GICH_LR_VIRTUALID;
> > +		is_v2_sgi = vgic_irq_is_sgi(intid);
> > +	}
> >
> > -		irq = vgic_get_vcpu_irq(vcpu, intid);
> > -		if (!irq)	/* An LPI could have been unmapped. */
> > -			continue;
> > +	irq = vgic_get_vcpu_irq(vcpu, intid);
> > +	if (!irq)	/* An LPI could have been unmapped. */
> > +		return;
> >
> > -		raw_spin_lock(&irq->irq_lock);
> > +	/* Notify fds when the guest EOI'ed a level-triggered IRQ */
> > +	if (lr_signals_eoi_mi(val) && vgic_valid_spi(vcpu->kvm, intid))
> > +		kvm_notify_acked_irq(vcpu->kvm, 0,
> > +				     intid - VGIC_NR_PRIVATE_IRQS);
> 
> The fds notifiy happens before checking irq's mapping before
> this patch, and now in reversal order w/ above change. It's
> fine for vLPI, and for vSPI no necessary call
> kvm_notify_acked_irq() if the it has been remapped, no
> gsi<->pin mapping there. Is above understanding correct ?

We can only notify an irqfd for an SPI, never for an LPI. Given that
only looking up an LPI can result in a NULL pointer (if it has been
concurrently removed), this change is immaterial

This results in something that is easier to understand, as I find it
more logical to weed out the error cases first before taking any
significant action.

Thanks,

	M.

-- 
Without deviation from the norm, progress is not possible.

