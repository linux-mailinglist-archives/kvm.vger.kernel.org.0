Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 8A2CC585A7E
	for <lists+kvm@lfdr.de>; Sat, 30 Jul 2022 14:52:48 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234199AbiG3Mwr (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Sat, 30 Jul 2022 08:52:47 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:60010 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230135AbiG3Mwq (ORCPT <rfc822;kvm@vger.kernel.org>);
        Sat, 30 Jul 2022 08:52:46 -0400
Received: from ams.source.kernel.org (ams.source.kernel.org [145.40.68.75])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0A46013D08
        for <kvm@vger.kernel.org>; Sat, 30 Jul 2022 05:52:45 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by ams.source.kernel.org (Postfix) with ESMTPS id AC990B80921
        for <kvm@vger.kernel.org>; Sat, 30 Jul 2022 12:52:42 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 496E5C433D6;
        Sat, 30 Jul 2022 12:52:41 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1659185561;
        bh=JfxghIyyY7ae2zetv+c7vg0QQtxMxJj3XBE6Wni/+EY=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=bs2uxrRYzT/TXifWcPLdVXvZKZgXZvHFXHqU5COGUpNIISh8je+llMuO4gafQ3hFK
         fHoqYQrt6MJPg4e+A8x9fWkc4v97Q19gQ3i9Ag16Aj0R/P8PKNQUEAbpXiGnhFt64R
         EoeXwOx7PCg4dnT75FPKdNWv78NsA4zBB0MHIs7z7LvN2/LnhwzZcMg83/+v/BsGol
         PibjhEu0fl3zdbbged6YUNfkZGE011zp1Sn+jiHrCpXW7c/nrRqmdOo+jQVmtvaVgB
         i9WyOkrxX0wNJraapb6wBG49jEBNFaJE40J0jHKgj59o5e3O8pXPd0zG1H/3e9AOGc
         LsRadopbY1cjw==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.95)
        (envelope-from <maz@kernel.org>)
        id 1oHlxO-00B2Q7-Vr;
        Sat, 30 Jul 2022 13:52:39 +0100
Date:   Sat, 30 Jul 2022 13:52:38 +0100
Message-ID: <87r122wynd.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Ricardo Koller <ricarkol@google.com>
Cc:     kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu,
        Andrew Jones <andrew.jones@linux.dev>,
        alexandru.elisei@arm.com, eric.auger@redhat.com,
        oliver.upton@linux.dev, reijiw@google.com
Subject: Re: [kvm-unit-tests PATCH 3/3] arm: pmu: Remove checks for !overflow in chained counters tests
In-Reply-To: <87sfmiwywd.wl-maz@kernel.org>
References: <20220718154910.3923412-1-ricarkol@google.com>
        <20220718154910.3923412-4-ricarkol@google.com>
        <87sfmiwywd.wl-maz@kernel.org>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: ricarkol@google.com, kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu, andrew.jones@linux.dev, alexandru.elisei@arm.com, eric.auger@redhat.com, oliver.upton@linux.dev, reijiw@google.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-7.7 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Crumbs... With Drew's new email this time.

On Sat, 30 Jul 2022 13:47:14 +0100,
Marc Zyngier <maz@kernel.org> wrote:
> 
> Hi Ricardo,
> 
> On Mon, 18 Jul 2022 16:49:10 +0100,
> Ricardo Koller <ricarkol@google.com> wrote:
> > 
> > A chained event overflowing on the low counter can set the overflow flag
> > in PMOVS.  KVM does not set it, but real HW and the fast-model seem to.
> > Moreover, the AArch64.IncrementEventCounter() pseudocode in the ARM ARM
> > (DDI 0487H.a, J1.1.1 "aarch64/debug") also sets the PMOVS bit on
> > overflow.
> > 
> > The pmu chain tests fail on bare metal when checking the overflow flag
> > of the low counter _not_ being set on overflow.  Fix by removing the
> > checks.
> > 
> > Signed-off-by: Ricardo Koller <ricarkol@google.com>
> > ---
> >  arm/pmu.c | 21 ++++++++++-----------
> >  1 file changed, 10 insertions(+), 11 deletions(-)
> > 
> > diff --git a/arm/pmu.c b/arm/pmu.c
> > index a7899c3c..4f2c5096 100644
> > --- a/arm/pmu.c
> > +++ b/arm/pmu.c
> > @@ -581,7 +581,6 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  
> >  	report(read_regn_el0(pmevcntr, 1) == 1, "CHAIN counter #1 incremented");
> > -	report(!read_sysreg(pmovsclr_el0), "no overflow recorded for chained incr #1");
> >  
> >  	/* test 64b overflow */
> >  
> > @@ -593,7 +592,7 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  	report_info("overflow reg = 0x%lx", read_sysreg(pmovsclr_el0));
> >  	report(read_regn_el0(pmevcntr, 1) == 2, "CHAIN counter #1 set to 2");
> > -	report(!read_sysreg(pmovsclr_el0), "no overflow recorded for chained incr #2");
> > +	report((read_sysreg(pmovsclr_el0) & 0x2) == 0, "no overflow recorded for chained incr #2");
> >  
> >  	write_regn_el0(pmevcntr, 0, PRE_OVERFLOW);
> >  	write_regn_el0(pmevcntr, 1, ALL_SET);
> > @@ -601,7 +600,7 @@ static void test_chained_counters(void)
> >  	precise_instrs_loop(22, pmu.pmcr_ro | PMU_PMCR_E);
> >  	report_info("overflow reg = 0x%lx", read_sysreg(pmovsclr_el0));
> >  	report(!read_regn_el0(pmevcntr, 1), "CHAIN counter #1 wrapped");
> > -	report(read_sysreg(pmovsclr_el0) == 0x2, "overflow on chain counter");
> > +	report(read_sysreg(pmovsclr_el0) & 0x2, "overflow on chain counter");
> >  }
> >  
> >  static void test_chained_sw_incr(void)
> > @@ -626,10 +625,10 @@ static void test_chained_sw_incr(void)
> >  	for (i = 0; i < 100; i++)
> >  		write_sysreg(0x1, pmswinc_el0);
> >  
> > -	report(!read_sysreg(pmovsclr_el0) && (read_regn_el0(pmevcntr, 1) == 1),
> > -		"no overflow and chain counter incremented after 100 SW_INCR/CHAIN");
> > +	report(read_regn_el0(pmevcntr, 1) == 1,
> > +			"no chain counter incremented after 100 SW_INCR/CHAIN");
> >  	report_info("overflow=0x%lx, #0=%ld #1=%ld", read_sysreg(pmovsclr_el0),
> > -		    read_regn_el0(pmevcntr, 0), read_regn_el0(pmevcntr, 1));
> > +			read_regn_el0(pmevcntr, 0), read_regn_el0(pmevcntr, 1));
> >  
> >  	/* 64b SW_INCR and overflow on CHAIN counter*/
> >  	pmu_reset();
> > @@ -644,7 +643,7 @@ static void test_chained_sw_incr(void)
> >  	for (i = 0; i < 100; i++)
> >  		write_sysreg(0x1, pmswinc_el0);
> >  
> > -	report((read_sysreg(pmovsclr_el0) == 0x2) &&
> > +	report((read_sysreg(pmovsclr_el0) & 0x2) &&
> >  		(read_regn_el0(pmevcntr, 1) == 0) &&
> >  		(read_regn_el0(pmevcntr, 0) == 84),
> >  		"overflow on chain counter and expected values after 100 SW_INCR/CHAIN");
> > @@ -727,8 +726,8 @@ static void test_chain_promotion(void)
> >  	report_info("MEM_ACCESS counter #0 has value 0x%lx",
> >  		    read_regn_el0(pmevcntr, 0));
> >  
> > -	report((read_regn_el0(pmevcntr, 1) == 1) && !read_sysreg(pmovsclr_el0),
> > -		"CHAIN counter enabled: CHAIN counter was incremented and no overflow");
> > +	report((read_regn_el0(pmevcntr, 1) == 1),
> > +		"CHAIN counter enabled: CHAIN counter was incremented");
> >  
> >  	report_info("CHAIN counter #1 = 0x%lx, overflow=0x%lx",
> >  		read_regn_el0(pmevcntr, 1), read_sysreg(pmovsclr_el0));
> > @@ -755,8 +754,8 @@ static void test_chain_promotion(void)
> >  	report_info("MEM_ACCESS counter #0 has value 0x%lx",
> >  		    read_regn_el0(pmevcntr, 0));
> >  
> > -	report((read_regn_el0(pmevcntr, 1) == 1) && !read_sysreg(pmovsclr_el0),
> > -		"32b->64b: CHAIN counter incremented and no overflow");
> > +	report((read_regn_el0(pmevcntr, 1) == 1),
> > +		"32b->64b: CHAIN counter incremented");
> >  
> >  	report_info("CHAIN counter #1 = 0x%lx, overflow=0x%lx",
> >  		read_regn_el0(pmevcntr, 1), read_sysreg(pmovsclr_el0));
> 
> I'm looking at fixing KVM to match this (see the binch of hacks at
> [1]), and still getting a couple of failures in the PMU overflow tests
> despite my best effort to fix the code:
> 
> $ ./arm-run  arm/pmu.flat --append pmu-overflow-interrupt
> /usr/bin/qemu-system-aarch64 -nodefaults -machine virt,gic-version=host -accel kvm -cpu host -device virtio-serial-device -device virtconsole,chardev=ctd -chardev testdev,id=ctd -device pci-testdev -display none -serial stdio -kernel arm/pmu.flat --append pmu-overflow-interrupt # -initrd /tmp/tmp.RQ6FmkvXay
> INFO: PMU version: 0x1
> INFO: PMU implementer/ID code: 0x41("A")/0x3
> INFO: Implements 6 event counters
> PASS: pmu: pmu-overflow-interrupt: no overflow interrupt after preset
> PASS: pmu: pmu-overflow-interrupt: no overflow interrupt after counting
> INFO: pmu: pmu-overflow-interrupt: overflow=0x0
> PASS: pmu: pmu-overflow-interrupt: overflow interrupts expected on #0 and #1
> FAIL: pmu: pmu-overflow-interrupt: no overflow interrupt expected on 32b boundary
> FAIL: pmu: pmu-overflow-interrupt: expect overflow interrupt on odd counter
> SUMMARY: 5 tests, 2 unexpected failures
> 
> Looking at the kut code, I'm wondering whether you're still missing a
> couple of extra fixes such as:
> 
> diff --git a/arm/pmu.c b/arm/pmu.c
> index 4f2c5096..e0b9f71a 100644
> --- a/arm/pmu.c
> +++ b/arm/pmu.c
> @@ -861,8 +861,8 @@ static void test_overflow_interrupt(void)
>  	write_regn_el0(pmevcntr, 0, PRE_OVERFLOW);
>  	isb();
>  	mem_access_loop(addr, 200, pmu.pmcr_ro | PMU_PMCR_E);
> -	report(expect_interrupts(0),
> -		"no overflow interrupt expected on 32b boundary");
> +	report(expect_interrupts(1),
> +		"expect overflow interrupt on 32b counter");
>  
>  	/* overflow on odd counter */
>  	pmu_reset_stats();
> @@ -870,8 +870,8 @@ static void test_overflow_interrupt(void)
>  	write_regn_el0(pmevcntr, 1, ALL_SET);
>  	isb();
>  	mem_access_loop(addr, 400, pmu.pmcr_ro | PMU_PMCR_E);
> -	report(expect_interrupts(0x2),
> -		"expect overflow interrupt on odd counter");
> +	report(expect_interrupts(0x3),
> +		"expect overflow interrupt on even+odd counters");
>  }
>  #endif
>  
> With that, all PMU tests pass. Am I missing something? Did you notice
> these failing on HW?
> 
> Thanks,
> 
> 	M.
> 
> [1] https://git.kernel.org/pub/scm/linux/kernel/git/maz/arm-platforms.git/log/?h=kvm-arm64/pmu-chained
> 
> -- 
> Without deviation from the norm, progress is not possible.

-- 
Without deviation from the norm, progress is not possible.
