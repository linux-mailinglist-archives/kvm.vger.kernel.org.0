Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id E3A7F2C3B3B
	for <lists+kvm@lfdr.de>; Wed, 25 Nov 2020 09:41:06 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726851AbgKYIj3 (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Wed, 25 Nov 2020 03:39:29 -0500
Received: from mail.kernel.org ([198.145.29.99]:60146 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726114AbgKYIj2 (ORCPT <rfc822;kvm@vger.kernel.org>);
        Wed, 25 Nov 2020 03:39:28 -0500
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org [51.254.78.96])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 4651E206F9;
        Wed, 25 Nov 2020 08:39:28 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1606293568;
        bh=eEJ5tvTMFCOh+2EgmsUylqMSCWDMdYDdOop9Zs0Wk+4=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=l/191OTg338rw+68Dnye0ev5H6ZLhvdRPn7/RM0z1TX3WWSs+XR7vUJCrmhcg1yYz
         Gwq7hcAqVZ+GppFQqdZZ3HrYMK6UTORgU8wj+amjmU8Ub4LY0fSUNZIqiZ/THgoOz4
         JAl9nSWoWT/rJYPirLyATMqSbQX8XMVTEMxG5O/E=
Received: from 78.163-31-62.static.virginmediabusiness.co.uk ([62.31.163.78] helo=wait-a-minute.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94)
        (envelope-from <maz@kernel.org>)
        id 1khqKk-00DTd2-1g; Wed, 25 Nov 2020 08:39:26 +0000
Date:   Wed, 25 Nov 2020 08:39:24 +0000
Message-ID: <877dq96dab.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Alexandru Elisei <alexandru.elisei@arm.com>
Cc:     linux-arm-kernel@lists.infradead.org, kvmarm@lists.cs.columbia.edu,
        kvm@vger.kernel.org, kernel-team@android.com
Subject: Re: [PATCH 0/8] KVM: arm64: Disabled PMU handling
In-Reply-To: <750f5543-054a-f1aa-229f-2d41b8e233dd@arm.com>
References: <20201113182602.471776-1-maz@kernel.org>
        <750f5543-054a-f1aa-229f-2d41b8e233dd@arm.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-SA-Exim-Connect-IP: 62.31.163.78
X-SA-Exim-Rcpt-To: alexandru.elisei@arm.com, linux-arm-kernel@lists.infradead.org, kvmarm@lists.cs.columbia.edu, kvm@vger.kernel.org, kernel-team@android.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

On Tue, 24 Nov 2020 17:28:30 +0000,
Alexandru Elisei <alexandru.elisei@arm.com> wrote:
>=20
> Hi Marc,
>=20
> I believe there is something missing from this series.
>=20
> The original behaviour, which this series changes, was not to do
> register emulation and PMU state update if the PMU wasn't ready,
> where vcpu->arch.pmu.ready was set to true if the PMU was
> initialized properly in kvm_vcpu_first_run_init() ->
> kvm_arm_pmu_v3_enable().
>=20
> The series changes PMU emulation such that register emulation and
> pmu state update is gated only on the VCPU feature being set. This
> means that now userspace can set the VCPU feature, don't do any
> initialization, and run a guest which can access PMU registers. Also
> kvm_pmu_update_state() will now be called before each VM entry. I'm
> not exactly sure what happens if we call kvm_vgic_inject_irq() for
> an irq_num =3D 0 and not owned by the PMU (the owner is set
> KVM_ARM_VCPU_PMU_V3_INIT -> kvm_arm_pmu_v3_init()), but I don't
> think that's allowed.

That's a very good point. I dropped the "ready" state a bit
carelessly, and nothing guards a half baked PMU anymore.

>=20
> I was also able to trigger this warning with a modified version of kvmtoo=
l:

[ugly warning]

> I removed all KVM_ARM_VCPU_PMU_V3_CTRL ioctl calls from kvmtool's
> pmu emulation, and I started the pmu test from kvm-unit-tests:
>=20
> $ ./lkvm-pmu run -c1 -m64 -f arm/pmu.flat --pmu -p cycle-counter
>=20
> The reason for the warning is that the correct value for
> kvm->arch.pmuver is set in kvm_arm_pmu_v3_set_attr(), which is not
> called anymore.
>=20
> This diff seems to solve the issue:
>=20
> diff --git a/arch/arm64/kvm/pmu-emul.c b/arch/arm64/kvm/pmu-emul.c
> index 643cf819f3c0..150b9cb0f741 100644
> --- a/arch/arm64/kvm/pmu-emul.c
> +++ b/arch/arm64/kvm/pmu-emul.c
> @@ -825,9 +825,12 @@ bool kvm_arm_support_pmu_v3(void)
> =C2=A0
> =C2=A0int kvm_arm_pmu_v3_enable(struct kvm_vcpu *vcpu)
> =C2=A0{
> -=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 if (!vcpu->arch.pmu.created)
> +=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 if (!kvm_vcpu_has_pmu(vcpu))
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0=C2=A0 return 0;
> =C2=A0
> +=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 if (!vcpu->arch.pmu.created)
> +=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=
=C2=A0=C2=A0 return -ENOEXEC;
> +
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 /*
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 * A valid interrupt conf=
iguration for the PMU is either to have a
> =C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0=C2=A0 * properly configured in=
terrupt number and using an in-kernel
>=20
> If you agree with the fix, I can send a proper patch.
> vcpu->arch.pmu.created is set in kvm_arm_pmu_v3_init(), which checks
> if the interrupt ID has been set. I chose to return -ENOEXEC=C2=A0
> because that's what KVM_RUN returns if the vcpu isn't initialized in
> kvm_arch_vcpu_ioctl_run().

Yes, this seems reasonable. The first run will fail, as for an
uninitialised vcpu.

Whist you're doing that, can you please document the ENOEXEC return
value? We only document EINTR so far.

Thanks,

	M.

--=20
Without deviation from the norm, progress is not possible.
