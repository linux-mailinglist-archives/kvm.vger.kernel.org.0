Return-Path: <kvm+bounces-14226-lists+kvm=lfdr.de@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from sy.mirrors.kernel.org (sy.mirrors.kernel.org [IPv6:2604:1380:40f1:3f00::1])
	by mail.lfdr.de (Postfix) with ESMTPS id 53BAA8A0AA5
	for <lists+kvm@lfdr.de>; Thu, 11 Apr 2024 09:55:40 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sy.mirrors.kernel.org (Postfix) with ESMTPS id 380FDB27E4C
	for <lists+kvm@lfdr.de>; Thu, 11 Apr 2024 07:53:50 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 3628A13FD94;
	Thu, 11 Apr 2024 07:53:17 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b="aeZ/v6pH"
X-Original-To: kvm@vger.kernel.org
Received: from smtp.kernel.org (aws-us-west-2-korg-mail-1.web.codeaurora.org [10.30.226.201])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 5A3E913F01E;
	Thu, 11 Apr 2024 07:53:16 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=10.30.226.201
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1712821996; cv=none; b=l1IpQOs6i+s1M7CT/ov5oRzziBVB1gqmjG0y5izkjjjFU4lLCtazPyDS3z/mo5D6l3dZHLJC/TEu+aQ2rRIoW3/nfdeTHfysSt28HpMH9tLgC5qu1hoLf3sXHBruahtyhgRtlHDtbtAHgurANHLNPtLD5tEVNYjqVQgn2StdfIo=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1712821996; c=relaxed/simple;
	bh=6EKuB8e7IExalHGky8lWzM8XAP+mtM0/jtPeWY6Ff7w=;
	h=Date:Message-ID:From:To:Cc:Subject:In-Reply-To:References:
	 MIME-Version:Content-Type; b=KNed5ByOjGtd5YBvbp4dJfY/RgKkcDTWntQqrOKO6bkjvmvzBtEmEXRLfW+eUUXauII8mzHCt7SHlD0CETL/e6YPk7sv+aqY7blo6o+7r5SqpOk9DOHYLfwZJqJvR7nh/HaWaPB7Pbb7qXOVe9KsKR1ttq64ZBTaMD7qHj4JWxg=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dkim=pass (2048-bit key) header.d=kernel.org header.i=@kernel.org header.b=aeZ/v6pH; arc=none smtp.client-ip=10.30.226.201
Received: by smtp.kernel.org (Postfix) with ESMTPSA id D6F9EC433F1;
	Thu, 11 Apr 2024 07:53:15 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
	s=k20201202; t=1712821995;
	bh=6EKuB8e7IExalHGky8lWzM8XAP+mtM0/jtPeWY6Ff7w=;
	h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
	b=aeZ/v6pH60KlfPIfvA+9/9CqjGnpSE1J5BHeGOcjxO4CPdb58eNlu7fuLSnW9YIMy
	 suGPjs4pcEF5wYoqtEZ3ApXLLxG0UOfQpCe8nU5dGxYJUX7yc6Uq0mFH8EEc6dPgeU
	 CgwQ0KKFuOWJD26kuD9vMJCRupdbnBPmSiOZ3m9W5clqwIVQVvjdkjiZiA/nJfOP+I
	 rvMWv+aX8g4wrkA/9IGKZ7gesau/gW4WNY3SAN/p4Eud2JhCbd9iHX8suE+BPqvIeU
	 xCMxLPAN99qIdbrztrsiNXpjRPXDjxQ1fwUF2otGBysSPrMHKM/0WCdBzc8xM4ePrE
	 sE2JrrU/v6TIQ==
Received: from sofa.misterjones.org ([185.219.108.64] helo=goblin-girl.misterjones.org)
	by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	(Exim 4.95)
	(envelope-from <maz@kernel.org>)
	id 1rupFB-003OqW-CZ;
	Thu, 11 Apr 2024 08:53:13 +0100
Date: Thu, 11 Apr 2024 08:53:13 +0100
Message-ID: <86sezss5cm.wl-maz@kernel.org>
From: Marc Zyngier <maz@kernel.org>
To: Colton Lewis <coltonlewis@google.com>
Cc: kvm@vger.kernel.org,
	Oliver Upton <oliver.upton@linux.dev>,
	James Morse <james.morse@arm.com>,
	Suzuki K Poulose <suzuki.poulose@arm.com>,
	Zenghui Yu <yuzenghui@huawei.com>,
	Catalin Marinas <catalin.marinas@arm.com>,
	Will Deacon <will@kernel.org>,
	linux-arm-kernel@lists.infradead.org,
	kvmarm@lists.linux.dev,
	linux-kernel@vger.kernel.org
Subject: Re: [PATCH v3] KVM: arm64: Add early_param to control WFx trapping
In-Reply-To: <20240410175437.793508-1-coltonlewis@google.com>
References: <20240410175437.793508-1-coltonlewis@google.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/29.2
 (aarch64-unknown-linux-gnu) MULE/6.0 (HANACHIRUSATO)
Precedence: bulk
X-Mailing-List: kvm@vger.kernel.org
List-Id: <kvm.vger.kernel.org>
List-Subscribe: <mailto:kvm+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:kvm+unsubscribe@vger.kernel.org>
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: coltonlewis@google.com, kvm@vger.kernel.org, oliver.upton@linux.dev, james.morse@arm.com, suzuki.poulose@arm.com, yuzenghui@huawei.com, catalin.marinas@arm.com, will@kernel.org, linux-arm-kernel@lists.infradead.org, kvmarm@lists.linux.dev, linux-kernel@vger.kernel.org
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false

On Wed, 10 Apr 2024 18:54:37 +0100,
Colton Lewis <coltonlewis@google.com> wrote:
> 
> Add an early_param to control WFx (WFI or WFE) trapping. This is so
> interrupts can be passed through if the CPU has support for direct
> interrupt injection, a feature of GICv4. This is described as an
> enumeration with three possible behaviors, always passthrough (never
> trap), never passthrough (always trap), or default (trap if more than
> one task is running. Default matches the current behavior.
> 
> Signed-off-by: Colton Lewis <coltonlewis@google.com>
> ---
> v3:
> * Changed control mechanism to an early_param on Marc's advice this should be
>   a system level decision and not exposed via uapi
> * Reduced behavior to an enum from an integer as there are only a few options
>   that make logical sense
> * Limit option for always passthrough to systems with GICv4 since the primary
>   case for always passthrough is systems with direct interrupt injection
> 
> v2:
> https://lore.kernel.org/kvmarm/20240319164341.1674863-1-coltonlewis@google.com/
> 
> v1:
> https://lore.kernel.org/kvmarm/20240129213918.3124494-1-coltonlewis@google.com/
> 
> arch/arm64/include/asm/kvm_host.h |  7 +++++++
>  arch/arm64/kvm/arm.c              | 30 +++++++++++++++++++++++++++++-
>  2 files changed, 36 insertions(+), 1 deletion(-)
> 
> diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h
> index 21c57b812569..e9225b1d0e9b 100644
> --- a/arch/arm64/include/asm/kvm_host.h
> +++ b/arch/arm64/include/asm/kvm_host.h
> @@ -67,6 +67,13 @@ enum kvm_mode {
>  	KVM_MODE_NV,
>  	KVM_MODE_NONE,
>  };
> +
> +enum kvm_interrupt_passthrough {
> +	KVM_INTERRUPT_PASSTHROUGH_DEFAULT,
> +	KVM_INTERRUPT_PASSTHROUGH_ALWAYS,
> +	KVM_INTERRUPT_PASSTHROUGH_NEVER,

What does this mean? This is not dealing with interrupts, this is
supposed to deal with the behaviour of specific instructions
(WFI/WFE). The notion of "passthrough" is really odd as well. Finally,
both ALWAYS and NEVER are wrong -- the architecture makes no such
guarantee.

> +};
> +
>  #ifdef CONFIG_KVM
>  enum kvm_mode kvm_get_mode(void);
>  #else
> diff --git a/arch/arm64/kvm/arm.c b/arch/arm64/kvm/arm.c
> index a25265aca432..5d0ea6b2c652 100644
> --- a/arch/arm64/kvm/arm.c
> +++ b/arch/arm64/kvm/arm.c
> @@ -46,6 +46,7 @@
>  #include <kvm/arm_psci.h>
> 
>  static enum kvm_mode kvm_mode = KVM_MODE_DEFAULT;
> +static enum kvm_interrupt_passthrough kvm_interrupt_passthrough = KVM_INTERRUPT_PASSTHROUGH_DEFAULT;
> 
>  DECLARE_KVM_HYP_PER_CPU(unsigned long, kvm_hyp_vector);
> 
> @@ -456,7 +457,10 @@ void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
>  	if (kvm_arm_is_pvtime_enabled(&vcpu->arch))
>  		kvm_make_request(KVM_REQ_RECORD_STEAL, vcpu);
> 
> -	if (single_task_running())
> +	if ((kvm_interrupt_passthrough == KVM_INTERRUPT_PASSTHROUGH_ALWAYS
> +	     && kvm_vgic_global_state.has_gicv4) ||
> +	    (kvm_interrupt_passthrough == KVM_INTERRUPT_PASSTHROUGH_DEFAULT
> +	     && single_task_running()))

Why is this affecting both WFI and WFE? They are very different and
lumping them together makes little sense.

>  		vcpu_clear_wfx_traps(vcpu);
>  	else
>  		vcpu_set_wfx_traps(vcpu);
> @@ -2654,6 +2658,30 @@ static int __init early_kvm_mode_cfg(char *arg)
>  }
>  early_param("kvm-arm.mode", early_kvm_mode_cfg);
> 
> +static int __init early_kvm_interrupt_passthrough_cfg(char *arg)
> +{
> +	if (!arg)
> +		return -EINVAL;
> +
> +	if (strcmp(arg, "always") == 0) {
> +		kvm_interrupt_passthrough = KVM_INTERRUPT_PASSTHROUGH_ALWAYS;
> +		return 0;
> +	}
> +
> +	if (strcmp(arg, "never") == 0) {
> +		kvm_interrupt_passthrough = KVM_INTERRUPT_PASSTHROUGH_NEVER;
> +		return 0;
> +	}
> +
> +	if (strcmp(arg, "default") == 0) {
> +		kvm_interrupt_passthrough = KVM_INTERRUPT_PASSTHROUGH_DEFAULT;
> +		return 0;
> +	}
> +
> +	return -EINVAL;
> +}
> +early_param("kvm-arm.interrupt-passthrough", early_kvm_interrupt_passthrough_cfg);
> +

Again, this is not dealing with interrupts. This is dealing with the
*potential* trapping of instructions in certain circumstances.

>  enum kvm_mode kvm_get_mode(void)
>  {
>  	return kvm_mode;

Finally, this needs to be documented.

Thanks,

	M.

-- 
Without deviation from the norm, progress is not possible.

