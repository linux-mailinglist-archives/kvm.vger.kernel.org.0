Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 04EA23F0979
	for <lists+kvm@lfdr.de>; Wed, 18 Aug 2021 18:45:55 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229839AbhHRQq2 (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Wed, 18 Aug 2021 12:46:28 -0400
Received: from mail.kernel.org ([198.145.29.99]:52480 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S229623AbhHRQq2 (ORCPT <rfc822;kvm@vger.kernel.org>);
        Wed, 18 Aug 2021 12:46:28 -0400
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org [51.254.78.96])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 77417610A6;
        Wed, 18 Aug 2021 16:45:53 +0000 (UTC)
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1mGOhL-005nlG-BY; Wed, 18 Aug 2021 17:45:51 +0100
Date:   Wed, 18 Aug 2021 17:45:50 +0100
Message-ID: <87fsv6snup.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Fuad Tabba <tabba@google.com>
Cc:     kvmarm@lists.cs.columbia.edu, will@kernel.org, james.morse@arm.com,
        alexandru.elisei@arm.com, suzuki.poulose@arm.com,
        mark.rutland@arm.com, christoffer.dall@arm.com,
        pbonzini@redhat.com, drjones@redhat.com, oupton@google.com,
        qperret@google.com, kvm@vger.kernel.org,
        linux-arm-kernel@lists.infradead.org, kernel-team@android.com
Subject: Re: [PATCH v4 11/15] KVM: arm64: Guest exit handlers for nVHE hyp
In-Reply-To: <20210817081134.2918285-12-tabba@google.com>
References: <20210817081134.2918285-1-tabba@google.com>
        <20210817081134.2918285-12-tabba@google.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: tabba@google.com, kvmarm@lists.cs.columbia.edu, will@kernel.org, james.morse@arm.com, alexandru.elisei@arm.com, suzuki.poulose@arm.com, mark.rutland@arm.com, christoffer.dall@arm.com, pbonzini@redhat.com, drjones@redhat.com, oupton@google.com, qperret@google.com, kvm@vger.kernel.org, linux-arm-kernel@lists.infradead.org, kernel-team@android.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

On Tue, 17 Aug 2021 09:11:30 +0100,
Fuad Tabba <tabba@google.com> wrote:
> 
> Add an array of pointers to handlers for various trap reasons in
> nVHE code.
> 
> The current code selects how to fixup a guest on exit based on a
> series of if/else statements. Future patches will also require
> different handling for guest exists. Create an array of handlers
> to consolidate them.
> 
> No functional change intended as the array isn't populated yet.
> 
> Acked-by: Will Deacon <will@kernel.org>
> Signed-off-by: Fuad Tabba <tabba@google.com>
> ---
>  arch/arm64/kvm/hyp/include/hyp/switch.h | 43 +++++++++++++++++++++++++
>  arch/arm64/kvm/hyp/nvhe/switch.c        | 33 +++++++++++++++++++
>  2 files changed, 76 insertions(+)
> 
> diff --git a/arch/arm64/kvm/hyp/include/hyp/switch.h b/arch/arm64/kvm/hyp/include/hyp/switch.h
> index a0e78a6027be..5a2b89b96c67 100644
> --- a/arch/arm64/kvm/hyp/include/hyp/switch.h
> +++ b/arch/arm64/kvm/hyp/include/hyp/switch.h
> @@ -409,6 +409,46 @@ static inline bool __hyp_handle_ptrauth(struct kvm_vcpu *vcpu)
>  	return true;
>  }
>  
> +typedef int (*exit_handle_fn)(struct kvm_vcpu *);

This returns an int...

> +
> +exit_handle_fn kvm_get_nvhe_exit_handler(struct kvm_vcpu *vcpu);
> +
> +static exit_handle_fn kvm_get_hyp_exit_handler(struct kvm_vcpu *vcpu)
> +{
> +	return is_nvhe_hyp_code() ? kvm_get_nvhe_exit_handler(vcpu) : NULL;
> +}
> +
> +/*
> + * Allow the hypervisor to handle the exit with an exit handler if it has one.
> + *
> + * Returns true if the hypervisor handled the exit, and control should go back
> + * to the guest, or false if it hasn't.
> + */
> +static bool kvm_hyp_handle_exit(struct kvm_vcpu *vcpu)
> +{
> +	bool is_handled = false;

... which you then implicitly cast as a bool.

> +	exit_handle_fn exit_handler = kvm_get_hyp_exit_handler(vcpu);
> +
> +	if (exit_handler) {
> +		/*
> +		 * There's limited vcpu context here since it's not synced yet.
> +		 * Ensure that relevant vcpu context that might be used by the
> +		 * exit_handler is in sync before it's called and if handled.
> +		 */
> +		*vcpu_pc(vcpu) = read_sysreg_el2(SYS_ELR);
> +		*vcpu_cpsr(vcpu) = read_sysreg_el2(SYS_SPSR);
> +
> +		is_handled = exit_handler(vcpu);

What does 'is_handled' mean here? By definition, any trap *must* be
handled, one way or another. By the look of it, what you really mean
is something like "I have updated the vcpu state and you'd better
reload it". Is that what it means?

> +
> +		if (is_handled) {
> +			write_sysreg_el2(*vcpu_pc(vcpu), SYS_ELR);
> +			write_sysreg_el2(*vcpu_cpsr(vcpu), SYS_SPSR);
> +		}
> +	}
> +
> +	return is_handled;
> +}

All these functions really should be marked inline. Have you checked
how this expands on VHE? I think some compilers could be pretty
unhappy about the undefined symbol in kvm_get_hyp_exit_handler().

It is also unfortunate that we get a bunch of tests for various
flavours of traps (FP, PAuth, page faults...), only to hit yet another
decoding tree. Is there a way we could use this infrastructure for
everything?

> +
>  /*
>   * Return true when we were able to fixup the guest exit and should return to
>   * the guest, false when we should restore the host state and return to the
> @@ -496,6 +536,9 @@ static inline bool fixup_guest_exit(struct kvm_vcpu *vcpu, u64 *exit_code)
>  			goto guest;
>  	}
>  
> +	/* Check if there's an exit handler and allow it to handle the exit. */
> +	if (kvm_hyp_handle_exit(vcpu))
> +		goto guest;
>  exit:
>  	/* Return to the host kernel and handle the exit */
>  	return false;
> diff --git a/arch/arm64/kvm/hyp/nvhe/switch.c b/arch/arm64/kvm/hyp/nvhe/switch.c
> index 86f3d6482935..b7f25307a7b9 100644
> --- a/arch/arm64/kvm/hyp/nvhe/switch.c
> +++ b/arch/arm64/kvm/hyp/nvhe/switch.c
> @@ -158,6 +158,39 @@ static void __pmu_switch_to_host(struct kvm_cpu_context *host_ctxt)
>  		write_sysreg(pmu->events_host, pmcntenset_el0);
>  }
>  
> +static exit_handle_fn hyp_exit_handlers[] = {
> +	[0 ... ESR_ELx_EC_MAX]		= NULL,
> +	[ESR_ELx_EC_WFx]		= NULL,
> +	[ESR_ELx_EC_CP15_32]		= NULL,
> +	[ESR_ELx_EC_CP15_64]		= NULL,
> +	[ESR_ELx_EC_CP14_MR]		= NULL,
> +	[ESR_ELx_EC_CP14_LS]		= NULL,
> +	[ESR_ELx_EC_CP14_64]		= NULL,
> +	[ESR_ELx_EC_HVC32]		= NULL,
> +	[ESR_ELx_EC_SMC32]		= NULL,
> +	[ESR_ELx_EC_HVC64]		= NULL,
> +	[ESR_ELx_EC_SMC64]		= NULL,
> +	[ESR_ELx_EC_SYS64]		= NULL,
> +	[ESR_ELx_EC_SVE]		= NULL,
> +	[ESR_ELx_EC_IABT_LOW]		= NULL,
> +	[ESR_ELx_EC_DABT_LOW]		= NULL,
> +	[ESR_ELx_EC_SOFTSTP_LOW]	= NULL,
> +	[ESR_ELx_EC_WATCHPT_LOW]	= NULL,
> +	[ESR_ELx_EC_BREAKPT_LOW]	= NULL,
> +	[ESR_ELx_EC_BKPT32]		= NULL,
> +	[ESR_ELx_EC_BRK64]		= NULL,
> +	[ESR_ELx_EC_FP_ASIMD]		= NULL,
> +	[ESR_ELx_EC_PAC]		= NULL,

You can safely drop all these and only keep the top one for now. This
will also keep the idiot robot at bay for until the next patch... ;-)

> +};
> +
> +exit_handle_fn kvm_get_nvhe_exit_handler(struct kvm_vcpu *vcpu)
> +{
> +	u32 esr = kvm_vcpu_get_esr(vcpu);
> +	u8 esr_ec = ESR_ELx_EC(esr);
> +
> +	return hyp_exit_handlers[esr_ec];
> +}
> +
>  /* Switch to the guest for legacy non-VHE systems */
>  int __kvm_vcpu_run(struct kvm_vcpu *vcpu)
>  {

Thanks,

	M.

-- 
Without deviation from the norm, progress is not possible.
