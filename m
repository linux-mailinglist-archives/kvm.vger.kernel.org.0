Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 0D0A1513B21
	for <lists+kvm@lfdr.de>; Thu, 28 Apr 2022 19:56:05 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240271AbiD1R7Q (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Thu, 28 Apr 2022 13:59:16 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:49762 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236683AbiD1R7P (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 28 Apr 2022 13:59:15 -0400
Received: from dfw.source.kernel.org (dfw.source.kernel.org [139.178.84.217])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3D8914B855
        for <kvm@vger.kernel.org>; Thu, 28 Apr 2022 10:56:00 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by dfw.source.kernel.org (Postfix) with ESMTPS id CC9AE60EAE
        for <kvm@vger.kernel.org>; Thu, 28 Apr 2022 17:55:59 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 09B79C385A0;
        Thu, 28 Apr 2022 17:55:59 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1651168559;
        bh=9Ml85O4d//534qMzyIAeeAr/06aIbwxqBxRD6bQ89qE=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=pcByehuR3uAqe8ECB/Bf+xD/cMGL204bxqSWuhOkIOh9NM+wMRDriHh5yLc4Tp2e3
         6yNB3Zc7eJJ6KtUN5PyMntWc2vQjGNUn+8m2tnkSzfdDBXTpQB+CYz2zHybQvixF3w
         6wx65ZyfCgwhECrf/9hOOIyJZ3yPyGJFM+/14zGW8xZcuwX/EMg9YPbqTTYqYI3zSJ
         xQ5d1g5ik0t4bpXM/DLUzcwyY0bh8I+EHmJMfRjNh3y7tpZSLt/UP+6s9exfHro7f9
         mWQasWyXnqIqPwbJtb96ZFW4xQ+QpulcyqN4F+semQj+d35N2O2X71PVIS44Ud4hE9
         P2iejsTjVg1gg==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1nk8Mu-007k5d-Ll; Thu, 28 Apr 2022 18:55:56 +0100
Date:   Thu, 28 Apr 2022 18:55:56 +0100
Message-ID: <87v8ut853n.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Alexandru Elisei <alexandru.elisei@arm.com>
Cc:     kvm@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
        kvmarm@lists.cs.columbia.edu, James Morse <james.morse@arm.com>,
        Suzuki K Poulose <suzuki.poulose@arm.com>,
        kernel-team@android.com, Quentin Perret <qperret@google.com>,
        Will Deacon <will@kernel.org>,
        Christoffer Dall <christoffer.dall@arm.com>
Subject: Re: [PATCH v2] KVM: arm64: Inject exception on out-of-IPA-range translation fault
In-Reply-To: <Ymq7qUU67DoXTmkP@monolith.localdoman>
References: <20220427220434.3097449-1-maz@kernel.org>
        <YmpUXWRJc3Kq3wGE@monolith.localdoman>
        <87zgk5b5bh.wl-maz@kernel.org>
        <Ymq7qUU67DoXTmkP@monolith.localdoman>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: alexandru.elisei@arm.com, kvm@vger.kernel.org, linux-arm-kernel@lists.infradead.org, kvmarm@lists.cs.columbia.edu, james.morse@arm.com, suzuki.poulose@arm.com, kernel-team@android.com, qperret@google.com, will@kernel.org, christoffer.dall@arm.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-7.7 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

On Thu, 28 Apr 2022 17:07:21 +0100,
Alexandru Elisei <alexandru.elisei@arm.com> wrote:
> 
> Hi,
> 
> On Thu, Apr 28, 2022 at 04:22:58PM +0100, Marc Zyngier wrote:
> > On Thu, 28 Apr 2022 09:46:21 +0100,
> > Alexandru Elisei <alexandru.elisei@arm.com> wrote:
> > > 
> > > Hi,
> > > 
> > > On Wed, Apr 27, 2022 at 11:04:34PM +0100, Marc Zyngier wrote:
> > > > When taking a translation fault for an IPA that is outside of
> > > > the range defined by the hypervisor (between the HW PARange and
> > > > the IPA range), we stupidly treat it as an IO and forward the access
> > > > to userspace. Of course, userspace can't do much with it, and things
> > > > end badly.
> > > > 
> > > > Arguably, the guest is braindead, but we should at least catch the
> > > > case and inject an exception.
> > > > 
> > > > Check the faulting IPA against:
> > > > - the sanitised PARange: inject an address size fault
> > > > - the IPA size: inject an abort
> > > > 
> > > > Reported-by: Christoffer Dall <christoffer.dall@arm.com>
> > > > Signed-off-by: Marc Zyngier <maz@kernel.org>
> > > > ---
> > > >  arch/arm64/include/asm/kvm_emulate.h |  1 +
> > > >  arch/arm64/kvm/inject_fault.c        | 28 ++++++++++++++++++++++++++++
> > > >  arch/arm64/kvm/mmu.c                 | 19 +++++++++++++++++++
> > > >  3 files changed, 48 insertions(+)
> > > > 
> > > > diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h
> > > > index 7496deab025a..f71358271b71 100644
> > > > --- a/arch/arm64/include/asm/kvm_emulate.h
> > > > +++ b/arch/arm64/include/asm/kvm_emulate.h
> > > > @@ -40,6 +40,7 @@ void kvm_inject_undefined(struct kvm_vcpu *vcpu);
> > > >  void kvm_inject_vabt(struct kvm_vcpu *vcpu);
> > > >  void kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr);
> > > >  void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr);
> > > > +void kvm_inject_size_fault(struct kvm_vcpu *vcpu);
> > > >  
> > > >  void kvm_vcpu_wfi(struct kvm_vcpu *vcpu);
> > > >  
> > > > diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c
> > > > index b47df73e98d7..ba20405d2dc2 100644
> > > > --- a/arch/arm64/kvm/inject_fault.c
> > > > +++ b/arch/arm64/kvm/inject_fault.c
> > > > @@ -145,6 +145,34 @@ void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr)
> > > >  		inject_abt64(vcpu, true, addr);
> > > >  }
> > > >  
> > > > +void kvm_inject_size_fault(struct kvm_vcpu *vcpu)
> > > > +{
> > > > +	unsigned long addr, esr;
> > > > +
> > > > +	addr  = kvm_vcpu_get_fault_ipa(vcpu);
> > > > +	addr |= kvm_vcpu_get_hfar(vcpu) & GENMASK(11, 0);
> > > > +
> > > > +	if (kvm_vcpu_trap_is_iabt(vcpu))
> > > > +		kvm_inject_pabt(vcpu, addr);
> > > > +	else
> > > > +		kvm_inject_dabt(vcpu, addr);
> > > > +
> > > > +	/*
> > > > +	 * If AArch64 or LPAE, set FSC to 0 to indicate an Address
> > > > +	 * Size Fault at level 0, as if exceeding PARange.
> > > > +	 *
> > > > +	 * Non-LPAE guests will only get the external abort, as there
> > > > +	 * is no way to to describe the ASF.
> > > > +	 */
> > > > +	if (vcpu_el1_is_32bit(vcpu) &&
> > > > +	    !(vcpu_read_sys_reg(vcpu, TCR_EL1) & TTBCR_EAE))
> > > > +		return;
> > > > +
> > > > +	esr = vcpu_read_sys_reg(vcpu, ESR_EL1);
> > > > +	esr &= ~GENMASK_ULL(5, 0);
> > > > +	vcpu_write_sys_reg(vcpu, esr, ESR_EL1);
> > > > +}
> > > > +
> > > >  /**
> > > >   * kvm_inject_undefined - inject an undefined instruction into the guest
> > > >   * @vcpu: The vCPU in which to inject the exception
> > > > diff --git a/arch/arm64/kvm/mmu.c b/arch/arm64/kvm/mmu.c
> > > > index 53ae2c0640bc..5400fc020164 100644
> > > > --- a/arch/arm64/kvm/mmu.c
> > > > +++ b/arch/arm64/kvm/mmu.c
> > > > @@ -1337,6 +1337,25 @@ int kvm_handle_guest_abort(struct kvm_vcpu *vcpu)
> > > >  	fault_ipa = kvm_vcpu_get_fault_ipa(vcpu);
> > > >  	is_iabt = kvm_vcpu_trap_is_iabt(vcpu);
> > > >  
> > > > +	if (fault_status == FSC_FAULT) {
> > > > +		/* Beyond sanitised PARange (which is the IPA limit) */
> > > > +		if (fault_ipa >= BIT_ULL(get_kvm_ipa_limit())) {
> > > > +			kvm_inject_size_fault(vcpu);
> > > > +			return 1;
> > > > +		}
> > > > +
> > > > +		/* Falls between the IPA range and the PARange? */
> > > > +		if (fault_ipa >= BIT_ULL(vcpu->arch.hw_mmu->pgt->ia_bits)) {
> > > > +			fault_ipa |= kvm_vcpu_get_hfar(vcpu) & GENMASK(11, 0);
> > > > +
> > > > +			if (is_iabt)
> > > > +				kvm_inject_pabt(vcpu, fault_ipa);
> > > > +			else
> > > > +				kvm_inject_dabt(vcpu, fault_ipa);
> > > > +			return 1;
> > > > +		}
> > > 
> > > Doesn't KVM treat faults outside a valid memslot (aka guest RAM) as MMIO
> > > aborts? From the guest's point of view, the IPA is valid because it's
> > > inside the HW PARange, so it's not entirely impossible that the VMM put a
> > > device there.
> > 
> > Sure. But the generated IPA is outside of the range the VMM has asked
> > to handle. The IPA space describes the whole of the guest address
> > space, and there shouldn't be anything outside of it.
> > 
> > We actually state in the documentation that the IPA Size limit *is*
> > the physical address size for the VM. If the VMM places something
> > outside if the IPA space and still expect something to be reported to
> > it, we have a problem (in some cases, we may want to actually put page
> > tables in place even for MMIO that traps to userspace -- see my
> > earlier work on MMIO guard).
> 
> If you mean this bit:
> 
> On arm64, the physical address size for a VM (IPA Size limit) is limited
> to 40bits by default. The limit can be configured if the host supports the
> extension KVM_CAP_ARM_VM_IPA_SIZE. When supported, use
> KVM_VM_TYPE_ARM_IPA_SIZE(IPA_Bits) to set the size in the machine type
> identifier, where IPA_Bits is the maximum width of any physical
> address used by the VM.
>
> And then below there is this paragraph:
> 
> Please note that configuring the IPA size does not affect the capability
> exposed by the guest CPUs in ID_AA64MMFR0_EL1[PARange]. It only affects
> **size of the address translated by the stage2 level (guest physical to
> host physical address translations)**.

I don't see that as a contradiction. It just says that we don't
repaint PARange.

> 
> Emphasis added by me.
> 
> It looks to me like the two paragraph state different things, first says
> the IPA size caps "the physical address size for a VM", the second that it
> caps the RAM size - "size of the address translated by the stage 2 level.

That's not the way I understand it. It just gives a textbook
definition of the IPA space. And to be clear, this is just an
implementation detail. We should be able to populate all full IPA
space with faulting entries and keep the behaviour the same.

> I have no problem with either, but it looks confusing.
> 
> So if a VMM that wants to put devices above RAM it must make sure that the
> IPA size is extended to match, did I get that right?

Yes. Anything that is reacheable by a memory transaction has to fit in
the IPA space.

> I'm also a bit confused about the rationale. Why is the PARange exposed to
> the guest in effect the wrong value, because the true PARange is defined by
> IPA size?

PARange and IPA range don't have the same granularity. You can't
express a PARange of 37 bits, for example, while it is perfectly
possible for the IPA range. And they do cover two different concepts:
the IPA space means nothing to the guest.

	M.

-- 
Without deviation from the norm, progress is not possible.
