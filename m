Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 15BEE25C5F2
	for <lists+kvm@lfdr.de>; Thu,  3 Sep 2020 17:57:24 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1728358AbgICP5W (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Thu, 3 Sep 2020 11:57:22 -0400
Received: from mail.kernel.org ([198.145.29.99]:56074 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1728806AbgICP4D (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 3 Sep 2020 11:56:03 -0400
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org [51.254.78.96])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 763C62072A;
        Thu,  3 Sep 2020 15:56:03 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=default; t=1599148563;
        bh=RtheV7zntSjszuTkTZNq3N4qWHVjJZ30ZDdbYBqb6bQ=;
        h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
        b=1UjjiO2eov6+tvS5ukHhmY1PUoxZ30d8DWaNcfYPOqEntFLNM9uB8uj2vp+R7lsxB
         EXf8cBNX5Zx6iSVlKXXyFqwsbT/oQgaKTFAFxNRTHCZttUzN4qoHaVNODXJ2RZBwOR
         Bq1FPFjCsXrG3/Ao577lZ56K9HWIxXEeHMWjEFI4=
Received: from 78.163-31-62.static.virginmediabusiness.co.uk ([62.31.163.78] helo=why.lan)
        by disco-boy.misterjones.org with esmtpsa (TLS1.3:ECDHE_RSA_AES_256_GCM_SHA384:256)
        (Exim 4.92)
        (envelope-from <maz@kernel.org>)
        id 1kDr8A-008vT9-M8; Thu, 03 Sep 2020 16:26:30 +0100
From:   Marc Zyngier <maz@kernel.org>
To:     kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu,
        linux-arm-kernel@lists.infradead.org
Cc:     kernel-team@android.com,
        Christoffer Dall <Christoffer.Dall@arm.com>,
        Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>,
        James Morse <james.morse@arm.com>,
        Julien Thierry <julien.thierry.kdev@gmail.com>,
        Suzuki K Poulose <suzuki.poulose@arm.com>
Subject: [PATCH 16/23] KVM: arm64: Move interrupt injection to irqchip_flow
Date:   Thu,  3 Sep 2020 16:26:03 +0100
Message-Id: <20200903152610.1078827-17-maz@kernel.org>
X-Mailer: git-send-email 2.27.0
In-Reply-To: <20200903152610.1078827-1-maz@kernel.org>
References: <20200903152610.1078827-1-maz@kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-SA-Exim-Connect-IP: 62.31.163.78
X-SA-Exim-Rcpt-To: kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu, linux-arm-kernel@lists.infradead.org, kernel-team@android.com, Christoffer.Dall@arm.com, lorenzo.pieralisi@arm.com, james.morse@arm.com, julien.thierry.kdev@gmail.com, suzuki.poulose@arm.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
Sender: kvm-owner@vger.kernel.org
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

As we continue abstracting away the VGIC, let's make a small
change while we're at it: Let's offer two callbacks for "wired"
interrupt injection:

- Interrupts generated from the kernel itself
- Interrupts generated by userspace via the KVM_IRQ_LINE ioctl

The various checks are pushed into the vgic code. MSI injection,
such as the one used by userspace to tickle the ITS are left alone
for now.

Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 arch/arm64/include/asm/kvm_irq.h | 11 +++++++++++
 arch/arm64/kvm/arch_timer.c      |  8 ++++----
 arch/arm64/kvm/arm.c             | 12 ++++--------
 arch/arm64/kvm/pmu-emul.c        |  4 ++--
 arch/arm64/kvm/vgic/vgic-init.c  |  2 ++
 arch/arm64/kvm/vgic/vgic.c       | 20 +++++++++++++++++++-
 arch/arm64/kvm/vgic/vgic.h       |  6 ++++++
 include/kvm/arm_vgic.h           |  2 --
 8 files changed, 48 insertions(+), 17 deletions(-)

diff --git a/arch/arm64/include/asm/kvm_irq.h b/arch/arm64/include/asm/kvm_irq.h
index 92aaec05ee75..f816d4814fcf 100644
--- a/arch/arm64/include/asm/kvm_irq.h
+++ b/arch/arm64/include/asm/kvm_irq.h
@@ -28,6 +28,11 @@ struct kvm_irqchip_flow {
 	int  (*irqchip_vcpu_first_run)(struct kvm_vcpu *);
 	void (*irqchip_vcpu_flush_hwstate)(struct kvm_vcpu *);
 	void (*irqchip_vcpu_sync_hwstate)(struct kvm_vcpu *);
+	int  (*irqchip_inject_irq)(struct kvm *, unsigned int cpu,
+				   unsigned int intid, bool, void *);
+	int  (*irqchip_inject_userspace_irq)(struct kvm *, unsigned int type,
+					     unsigned int cpu,
+					     unsigned int intid, bool);
 };
 
 /*
@@ -86,4 +91,10 @@ struct kvm_irqchip_flow {
 #define kvm_irqchip_vcpu_sync_hwstate(v)		\
 	__vcpu_irqchip_action((v), vcpu_sync_hwstate, (v))
 
+#define kvm_irqchip_inject_irq(k, ...)			\
+	__kvm_irqchip_action_ret((k), inject_irq, (k), __VA_ARGS__)
+
+#define kvm_irqchip_inject_userspace_irq(k, ...)	\
+	__kvm_irqchip_action_ret((k), inject_userspace_irq, (k), __VA_ARGS__)
+
 #endif
diff --git a/arch/arm64/kvm/arch_timer.c b/arch/arm64/kvm/arch_timer.c
index 32ba6fbc3814..397bd7aea1f5 100644
--- a/arch/arm64/kvm/arch_timer.c
+++ b/arch/arm64/kvm/arch_timer.c
@@ -388,10 +388,10 @@ static void kvm_timer_update_irq(struct kvm_vcpu *vcpu, bool new_level,
 				   timer_ctx->irq.level);
 
 	if (!userspace_irqchip(vcpu->kvm)) {
-		ret = kvm_vgic_inject_irq(vcpu->kvm, vcpu->vcpu_id,
-					  timer_ctx->irq.irq,
-					  timer_ctx->irq.level,
-					  timer_ctx);
+		ret = kvm_irqchip_inject_irq(vcpu->kvm, vcpu->vcpu_id,
+					     timer_ctx->irq.irq,
+					     timer_ctx->irq.level,
+					     timer_ctx);
 		WARN_ON(ret);
 	}
 }
diff --git a/arch/arm64/kvm/arm.c b/arch/arm64/kvm/arm.c
index 875e68514661..139f4154038b 100644
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@ -870,18 +870,14 @@ int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level,
 		if (!vcpu)
 			return -EINVAL;
 
-		if (irq_num < VGIC_NR_SGIS || irq_num >= VGIC_NR_PRIVATE_IRQS)
-			return -EINVAL;
-
-		return kvm_vgic_inject_irq(kvm, vcpu->vcpu_id, irq_num, level, NULL);
+		return kvm_irqchip_inject_userspace_irq(kvm, irq_type, vcpu_idx,
+							irq_num, level);
 	case KVM_ARM_IRQ_TYPE_SPI:
 		if (!irqchip_in_kernel(kvm))
 			return -ENXIO;
 
-		if (irq_num < VGIC_NR_PRIVATE_IRQS)
-			return -EINVAL;
-
-		return kvm_vgic_inject_irq(kvm, 0, irq_num, level, NULL);
+		return kvm_irqchip_inject_userspace_irq(kvm, irq_type, 0,
+							irq_num, level);
 	}
 
 	return -EINVAL;
diff --git a/arch/arm64/kvm/pmu-emul.c b/arch/arm64/kvm/pmu-emul.c
index f0d0312c0a55..f31ee6ad3444 100644
--- a/arch/arm64/kvm/pmu-emul.c
+++ b/arch/arm64/kvm/pmu-emul.c
@@ -378,8 +378,8 @@ static void kvm_pmu_update_state(struct kvm_vcpu *vcpu)
 	pmu->irq_level = overflow;
 
 	if (likely(irqchip_in_kernel(vcpu->kvm))) {
-		int ret = kvm_vgic_inject_irq(vcpu->kvm, vcpu->vcpu_id,
-					      pmu->irq_num, overflow, pmu);
+		int ret = kvm_irqchip_inject_irq(vcpu->kvm, vcpu->vcpu_id,
+						 pmu->irq_num, overflow, pmu);
 		WARN_ON(ret);
 	}
 }
diff --git a/arch/arm64/kvm/vgic/vgic-init.c b/arch/arm64/kvm/vgic/vgic-init.c
index 53fadbf4ca89..7a8504a5b634 100644
--- a/arch/arm64/kvm/vgic/vgic-init.c
+++ b/arch/arm64/kvm/vgic/vgic-init.c
@@ -27,6 +27,8 @@ static struct kvm_irqchip_flow vgic_irqchip_flow = {
 	.irqchip_vcpu_first_run		= kvm_vgic_vcpu_first_run,
 	.irqchip_vcpu_flush_hwstate	= kvm_vgic_flush_hwstate,
 	.irqchip_vcpu_sync_hwstate	= kvm_vgic_sync_hwstate,
+	.irqchip_inject_irq		= kvm_vgic_inject_irq,
+	.irqchip_inject_userspace_irq	= kvm_vgic_inject_userspace_irq,
 };
 
 /*
diff --git a/arch/arm64/kvm/vgic/vgic.c b/arch/arm64/kvm/vgic/vgic.c
index f576273c5608..d676c010e45f 100644
--- a/arch/arm64/kvm/vgic/vgic.c
+++ b/arch/arm64/kvm/vgic/vgic.c
@@ -434,7 +434,7 @@ bool vgic_queue_irq_unlock(struct kvm *kvm, struct vgic_irq *irq,
  * level-sensitive interrupts.  You can think of the level parameter as 1
  * being HIGH and 0 being LOW and all devices being active-HIGH.
  */
-int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
+int kvm_vgic_inject_irq(struct kvm *kvm, unsigned int cpuid, unsigned int intid,
 			bool level, void *owner)
 {
 	struct kvm_vcpu *vcpu;
@@ -476,6 +476,24 @@ int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
 	return 0;
 }
 
+int kvm_vgic_inject_userspace_irq(struct kvm *kvm, unsigned int type,
+				  unsigned int cpuid, unsigned int intid,
+				  bool level)
+{
+	switch (type) {
+	case KVM_ARM_IRQ_TYPE_PPI:
+		if (intid < VGIC_NR_SGIS || intid >= VGIC_NR_PRIVATE_IRQS)
+			return -EINVAL;
+		return kvm_vgic_inject_irq(kvm, cpuid, intid, level, NULL);
+	case KVM_ARM_IRQ_TYPE_SPI:
+		if (intid < VGIC_NR_PRIVATE_IRQS)
+			return -EINVAL;
+		return kvm_vgic_inject_irq(kvm, 0, intid, level, NULL);
+	default:
+		return -EINVAL;
+	}
+}
+
 /* @irq->irq_lock must be held */
 static int kvm_vgic_map_irq(struct kvm_vcpu *vcpu, struct vgic_irq *irq,
 			    unsigned int host_irq,
diff --git a/arch/arm64/kvm/vgic/vgic.h b/arch/arm64/kvm/vgic/vgic.h
index 48e9efda9d8b..cddbd9b951e4 100644
--- a/arch/arm64/kvm/vgic/vgic.h
+++ b/arch/arm64/kvm/vgic/vgic.h
@@ -232,6 +232,12 @@ void vgic_v3_vmcr_sync(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_blocking(struct kvm_vcpu *vcpu);
 void kvm_vgic_vcpu_unblocking(struct kvm_vcpu *vcpu);
 
+int kvm_vgic_inject_irq(struct kvm *kvm, unsigned int cpuid, unsigned int intid,
+			bool level, void *owner);
+int kvm_vgic_inject_userspace_irq(struct kvm *kvm, unsigned int type,
+				  unsigned int cpuid, unsigned int intid,
+				  bool level);
+
 bool vgic_has_its(struct kvm *kvm);
 int kvm_vgic_register_its_device(void);
 void vgic_enable_lpis(struct kvm_vcpu *vcpu);
diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h
index 4b3a334185fa..fba68129337d 100644
--- a/include/kvm/arm_vgic.h
+++ b/include/kvm/arm_vgic.h
@@ -339,8 +339,6 @@ int kvm_vgic_create(struct kvm *kvm, u32 type);
 int kvm_vgic_hyp_init(void);
 void kvm_vgic_init_cpu_hardware(void);
 
-int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int intid,
-			bool level, void *owner);
 int kvm_vgic_map_phys_irq(struct kvm_vcpu *vcpu, unsigned int host_irq,
 			  u32 vintid, bool (*get_input_level)(int vindid));
 int kvm_vgic_unmap_phys_irq(struct kvm_vcpu *vcpu, unsigned int vintid);
-- 
2.27.0

