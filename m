Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 7BDD54018A5
	for <lists+kvm@lfdr.de>; Mon,  6 Sep 2021 11:12:29 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S241157AbhIFJNT (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Mon, 6 Sep 2021 05:13:19 -0400
Received: from mail.kernel.org ([198.145.29.99]:37864 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S240897AbhIFJNS (ORCPT <rfc822;kvm@vger.kernel.org>);
        Mon, 6 Sep 2021 05:13:18 -0400
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org [51.254.78.96])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 6E1BD60F14;
        Mon,  6 Sep 2021 09:12:14 +0000 (UTC)
Received: from 82-132-228-124.dab.02.net ([82.132.228.124] helo=wait-a-minute.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1mNAfk-009DhA-9T; Mon, 06 Sep 2021 10:12:12 +0100
Date:   Mon, 06 Sep 2021 10:12:12 +0100
Message-ID: <87ilzecbkj.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Oliver Upton <oupton@google.com>
Cc:     kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu,
        Peter Shier <pshier@google.com>,
        Ricardo Koller <ricarkol@google.com>,
        Jing Zhang <jingzhangos@google.com>,
        Raghavendra Rao Anata <rananta@google.com>,
        James Morse <james.morse@arm.com>,
        Alexandru Elisei <alexandru.elisei@arm.com>,
        Suzuki K Poulose <suzuki.poulose@arm.com>,
        Andrew Jones <drjones@redhat.com>
Subject: Re: [PATCH 0/6] KVM: arm64: Implement PSCI SYSTEM_SUSPEND support
In-Reply-To: <20210819223640.3564975-1-oupton@google.com>
References: <20210819223640.3564975-1-oupton@google.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 82.132.228.124
X-SA-Exim-Rcpt-To: oupton@google.com, kvm@vger.kernel.org, kvmarm@lists.cs.columbia.edu, pshier@google.com, ricarkol@google.com, jingzhangos@google.com, rananta@google.com, james.morse@arm.com, alexandru.elisei@arm.com, suzuki.poulose@arm.com, drjones@redhat.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

Hi Oliver,

On Thu, 19 Aug 2021 23:36:34 +0100,
Oliver Upton <oupton@google.com> wrote:
> 
> Certain VMMs/operators may wish to give their guests the ability to
> initiate a system suspend that could result in the VM being saved to
> persistent storage to be resumed at a later time. The PSCI v1.0
> specification describes an SMC, SYSTEM_SUSPEND, that allows a kernel to
> request a system suspend. This call is optional for v1.0, and KVM
> elected to not support the call in its v1.0 implementation.
> 
> This series adds support for the SYSTEM_SUSPEND PSCI call to KVM/arm64.
> Since this is a system-scoped event, KVM cannot quiesce the VM on its
> own. We add a new system exit type in this series to clue in userspace
> that a suspend was requested. Per the KVM_EXIT_SYSTEM_EVENT ABI, a VMM
> that doesn't care about this event can simply resume the guest without
> issue (we set up the calling vCPU to come out of reset correctly on next
> KVM_RUN).

More idle thoughts on this:

Although the definition of SYSTEM_SUSPEND is very simple from a PSCI
perspective, I don't think it is that simple at the system level,
because PSCI is only concerned with the CPU.

For example, what is a wake-up event? My first approach would be to
consider interrupts to be such events. However, this approach suffers
from at least two issues:

- How do you define which interrupts are actual wake-up events?
  Nothing in the GIC architecture defines what a wake-up is (let alone
  a wake-up event).

- Assuming you have a way to express the above, how do you handle
  wake-ups from interrupts that have their source in the kernel (such
  as timers, irqfd sources)? How do you cope with directly injected
  interrupts?

It looks to me that your implementation can only work with userspace
provided events, which is pretty limited.

Other items worth considering: ongoing DMA, state of the caches at
suspend time, device state in general All of this really needs to be
defined before we can move forward with this feature.

Thanks,

	M.

-- 
Without deviation from the norm, progress is not possible.
