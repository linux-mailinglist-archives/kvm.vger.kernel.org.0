Return-Path: <kvm-owner@vger.kernel.org>
X-Original-To: lists+kvm@lfdr.de
Delivered-To: lists+kvm@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 1414A513838
	for <lists+kvm@lfdr.de>; Thu, 28 Apr 2022 17:24:12 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1349057AbiD1P01 (ORCPT <rfc822;lists+kvm@lfdr.de>);
        Thu, 28 Apr 2022 11:26:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36582 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1349094AbiD1P0Y (ORCPT <rfc822;kvm@vger.kernel.org>);
        Thu, 28 Apr 2022 11:26:24 -0400
Received: from ams.source.kernel.org (ams.source.kernel.org [IPv6:2604:1380:4601:e00::1])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4D0EFB6E7F
        for <kvm@vger.kernel.org>; Thu, 28 Apr 2022 08:23:08 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by ams.source.kernel.org (Postfix) with ESMTPS id DB98AB82E0F
        for <kvm@vger.kernel.org>; Thu, 28 Apr 2022 15:23:06 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 89E8CC385AA;
        Thu, 28 Apr 2022 15:23:05 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1651159385;
        bh=a+g7kB1z4KoOUj5wf8DAfU3CDt6Jxq6eIpCUJLbn5n4=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=PbSACN0rbItX49rjK7eSne4lvayB2pyOPyuARhcjXZK/g1FU3CCGTF9Kee2tVT8H4
         Y9NUNSqkKqVNgiCj3tXSa9Rhg16RqouOXyJIvSHlDRdwIZXQSwYWijMCfDNTP8HOH6
         YglNhEQTFGx/43Hh6LNu4bzv7c2Q3bl010WiE4djB6fFpCloYBh0xhkGBp1SJTyDqi
         BITDyDBZqbkGv+c8EDnobZGUE3AN6mWCukrk0pUM7UidGff0oFNVuv57Lpydouz+Xg
         5ZgBypNRBZpcnxZnqv+Q4bvMBGqFCSHdY0cpg1+8GzNQ7XnJ+vtZMOEQcTsey0cNOi
         lCQp2O1ew26eQ==
Received: from [104.133.9.104] (helo=billy-the-mountain.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94.2)
        (envelope-from <maz@kernel.org>)
        id 1nk5yw-007huq-MB; Thu, 28 Apr 2022 16:23:03 +0100
Date:   Thu, 28 Apr 2022 16:22:58 +0100
Message-ID: <87zgk5b5bh.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Alexandru Elisei <alexandru.elisei@arm.com>
Cc:     kvm@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
        kvmarm@lists.cs.columbia.edu, James Morse <james.morse@arm.com>,
        Suzuki K Poulose <suzuki.poulose@arm.com>,
        kernel-team@android.com, Quentin Perret <qperret@google.com>,
        Will Deacon <will@kernel.org>,
        Christoffer Dall <christoffer.dall@arm.com>
Subject: Re: [PATCH v2] KVM: arm64: Inject exception on out-of-IPA-range translation fault
In-Reply-To: <YmpUXWRJc3Kq3wGE@monolith.localdoman>
References: <20220427220434.3097449-1-maz@kernel.org>
        <YmpUXWRJc3Kq3wGE@monolith.localdoman>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (aarch64-unknown-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 104.133.9.104
X-SA-Exim-Rcpt-To: alexandru.elisei@arm.com, kvm@vger.kernel.org, linux-arm-kernel@lists.infradead.org, kvmarm@lists.cs.columbia.edu, james.morse@arm.com, suzuki.poulose@arm.com, kernel-team@android.com, qperret@google.com, will@kernel.org, christoffer.dall@arm.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-7.7 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <kvm.vger.kernel.org>
X-Mailing-List: kvm@vger.kernel.org

On Thu, 28 Apr 2022 09:46:21 +0100,
Alexandru Elisei <alexandru.elisei@arm.com> wrote:
> 
> Hi,
> 
> On Wed, Apr 27, 2022 at 11:04:34PM +0100, Marc Zyngier wrote:
> > When taking a translation fault for an IPA that is outside of
> > the range defined by the hypervisor (between the HW PARange and
> > the IPA range), we stupidly treat it as an IO and forward the access
> > to userspace. Of course, userspace can't do much with it, and things
> > end badly.
> > 
> > Arguably, the guest is braindead, but we should at least catch the
> > case and inject an exception.
> > 
> > Check the faulting IPA against:
> > - the sanitised PARange: inject an address size fault
> > - the IPA size: inject an abort
> > 
> > Reported-by: Christoffer Dall <christoffer.dall@arm.com>
> > Signed-off-by: Marc Zyngier <maz@kernel.org>
> > ---
> >  arch/arm64/include/asm/kvm_emulate.h |  1 +
> >  arch/arm64/kvm/inject_fault.c        | 28 ++++++++++++++++++++++++++++
> >  arch/arm64/kvm/mmu.c                 | 19 +++++++++++++++++++
> >  3 files changed, 48 insertions(+)
> > 
> > diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h
> > index 7496deab025a..f71358271b71 100644
> > --- a/arch/arm64/include/asm/kvm_emulate.h
> > +++ b/arch/arm64/include/asm/kvm_emulate.h
> > @@ -40,6 +40,7 @@ void kvm_inject_undefined(struct kvm_vcpu *vcpu);
> >  void kvm_inject_vabt(struct kvm_vcpu *vcpu);
> >  void kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr);
> >  void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr);
> > +void kvm_inject_size_fault(struct kvm_vcpu *vcpu);
> >  
> >  void kvm_vcpu_wfi(struct kvm_vcpu *vcpu);
> >  
> > diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c
> > index b47df73e98d7..ba20405d2dc2 100644
> > --- a/arch/arm64/kvm/inject_fault.c
> > +++ b/arch/arm64/kvm/inject_fault.c
> > @@ -145,6 +145,34 @@ void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr)
> >  		inject_abt64(vcpu, true, addr);
> >  }
> >  
> > +void kvm_inject_size_fault(struct kvm_vcpu *vcpu)
> > +{
> > +	unsigned long addr, esr;
> > +
> > +	addr  = kvm_vcpu_get_fault_ipa(vcpu);
> > +	addr |= kvm_vcpu_get_hfar(vcpu) & GENMASK(11, 0);
> > +
> > +	if (kvm_vcpu_trap_is_iabt(vcpu))
> > +		kvm_inject_pabt(vcpu, addr);
> > +	else
> > +		kvm_inject_dabt(vcpu, addr);
> > +
> > +	/*
> > +	 * If AArch64 or LPAE, set FSC to 0 to indicate an Address
> > +	 * Size Fault at level 0, as if exceeding PARange.
> > +	 *
> > +	 * Non-LPAE guests will only get the external abort, as there
> > +	 * is no way to to describe the ASF.
> > +	 */
> > +	if (vcpu_el1_is_32bit(vcpu) &&
> > +	    !(vcpu_read_sys_reg(vcpu, TCR_EL1) & TTBCR_EAE))
> > +		return;
> > +
> > +	esr = vcpu_read_sys_reg(vcpu, ESR_EL1);
> > +	esr &= ~GENMASK_ULL(5, 0);
> > +	vcpu_write_sys_reg(vcpu, esr, ESR_EL1);
> > +}
> > +
> >  /**
> >   * kvm_inject_undefined - inject an undefined instruction into the guest
> >   * @vcpu: The vCPU in which to inject the exception
> > diff --git a/arch/arm64/kvm/mmu.c b/arch/arm64/kvm/mmu.c
> > index 53ae2c0640bc..5400fc020164 100644
> > --- a/arch/arm64/kvm/mmu.c
> > +++ b/arch/arm64/kvm/mmu.c
> > @@ -1337,6 +1337,25 @@ int kvm_handle_guest_abort(struct kvm_vcpu *vcpu)
> >  	fault_ipa = kvm_vcpu_get_fault_ipa(vcpu);
> >  	is_iabt = kvm_vcpu_trap_is_iabt(vcpu);
> >  
> > +	if (fault_status == FSC_FAULT) {
> > +		/* Beyond sanitised PARange (which is the IPA limit) */
> > +		if (fault_ipa >= BIT_ULL(get_kvm_ipa_limit())) {
> > +			kvm_inject_size_fault(vcpu);
> > +			return 1;
> > +		}
> > +
> > +		/* Falls between the IPA range and the PARange? */
> > +		if (fault_ipa >= BIT_ULL(vcpu->arch.hw_mmu->pgt->ia_bits)) {
> > +			fault_ipa |= kvm_vcpu_get_hfar(vcpu) & GENMASK(11, 0);
> > +
> > +			if (is_iabt)
> > +				kvm_inject_pabt(vcpu, fault_ipa);
> > +			else
> > +				kvm_inject_dabt(vcpu, fault_ipa);
> > +			return 1;
> > +		}
> 
> Doesn't KVM treat faults outside a valid memslot (aka guest RAM) as MMIO
> aborts? From the guest's point of view, the IPA is valid because it's
> inside the HW PARange, so it's not entirely impossible that the VMM put a
> device there.

Sure. But the generated IPA is outside of the range the VMM has asked
to handle. The IPA space describes the whole of the guest address
space, and there shouldn't be anything outside of it.

We actually state in the documentation that the IPA Size limit *is*
the physical address size for the VM. If the VMM places something
outside if the IPA space and still expect something to be reported to
it, we have a problem (in some cases, we may want to actually put page
tables in place even for MMIO that traps to userspace -- see my
earlier work on MMIO guard).

Does it make sense to you?

	M.

-- 
Without deviation from the norm, progress is not possible.
